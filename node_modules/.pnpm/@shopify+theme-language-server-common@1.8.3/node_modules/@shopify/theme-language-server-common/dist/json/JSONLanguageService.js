"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONLanguageService = void 0;
const liquid_html_parser_1 = require("@shopify/liquid-html-parser");
const theme_check_common_1 = require("@shopify/theme-check-common");
const vscode_json_languageservice_1 = require("vscode-json-languageservice");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const visitor_1 = require("../visitor");
const TranslationFileContributions_1 = require("./TranslationFileContributions");
const SectionSchemaURI = 'https://raw.githubusercontent.com/Shopify/theme-liquid-docs/main/schemas/theme/section_schema.json';
const TranslationFileURI = 'https://raw.githubusercontent.com/Shopify/theme-liquid-docs/main/schemas/theme/translations_schema.json';
class JSONLanguageService {
    constructor(documentManager, jsonValidationSet) {
        this.documentManager = documentManager;
        this.jsonValidationSet = jsonValidationSet;
        this.service = null;
    }
    setup(clientCapabilities) {
        this.service = (0, vscode_json_languageservice_1.getLanguageService)({
            schemaRequestService: this.getSchemaForURI.bind(this),
            contributions: [new TranslationFileContributions_1.TranslationFileContributions(this.documentManager)],
            clientCapabilities,
        });
        this.service.configure({
            schemas: [
                {
                    uri: SectionSchemaURI,
                    fileMatch: ['**/sections/*.liquid'],
                },
                {
                    uri: TranslationFileURI,
                    fileMatch: [
                        '**/locales/*.json',
                        '**/locales/*.default.json',
                        '**/locales/*.schema.json',
                        '**/locales/*.default.schema.json',
                    ],
                },
            ],
        });
    }
    async completions(params) {
        if (!this.service)
            return null;
        const documents = this.getDocuments(params);
        if (!documents)
            return null;
        const [jsonTextDocument, jsonDocument] = documents;
        return this.service.doComplete(jsonTextDocument, params.position, jsonDocument);
    }
    async hover(params) {
        if (!this.service)
            return null;
        const documents = this.getDocuments(params);
        if (!documents)
            return null;
        const [jsonTextDocument, jsonDocument] = documents;
        return this.service.doHover(jsonTextDocument, params.position, jsonDocument);
    }
    getDocuments(params) {
        if (!this.service)
            return null;
        const document = this.documentManager.get(params.textDocument.uri);
        if (!document)
            return null;
        switch (document.type) {
            case theme_check_common_1.SourceCodeType.JSON: {
                const jsonTextDocument = document.textDocument;
                const jsonDocument = this.service.parseJSONDocument(jsonTextDocument);
                return [jsonTextDocument, jsonDocument];
            }
            case theme_check_common_1.SourceCodeType.LiquidHtml: {
                if (document.ast instanceof Error)
                    return null;
                const textDocument = document.textDocument;
                const offset = textDocument.offsetAt(params.position);
                const [_, ancestors] = (0, visitor_1.findCurrentNode)(document.ast, offset);
                const schema = ancestors.find((node) => node.type === liquid_html_parser_1.NodeTypes.LiquidRawTag && node.name === 'schema');
                if (!schema)
                    return null;
                const schemaLineNumber = textDocument.positionAt(schema.blockStartPosition.end).line;
                // Hacking away "same line numbers" here by prefixing the file with newlines
                // This way params.position will be at the same line number in this fake jsonTextDocument
                // Which means that the completions will be at the same line number in the Liquid document
                const jsonString = Array(schemaLineNumber).fill('\n').join('') +
                    schema.source.slice(schema.blockStartPosition.end, schema.blockEndPosition.start);
                const jsonTextDocument = vscode_languageserver_textdocument_1.TextDocument.create(textDocument.uri, 'json', textDocument.version, jsonString);
                const jsonDocument = this.service.parseJSONDocument(jsonTextDocument);
                return [jsonTextDocument, jsonDocument];
            }
        }
    }
    async getSchemaForURI(uri) {
        switch (uri) {
            case SectionSchemaURI:
                return this.jsonValidationSet.sectionSchema();
            case TranslationFileURI:
                return this.jsonValidationSet.translationSchema();
            default:
                throw new Error(`No schema for ${uri}`);
        }
    }
}
exports.JSONLanguageService = JSONLanguageService;
//# sourceMappingURL=JSONLanguageService.js.map