"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = void 0;
const theme_check_common_1 = require("@shopify/theme-check-common");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const ClientCapabilities_1 = require("../ClientCapabilities");
const codeActions_1 = require("../codeActions");
const commands_1 = require("../commands");
const completions_1 = require("../completions");
const diagnostics_1 = require("../diagnostics");
const documentLinks_1 = require("../documentLinks");
const documents_1 = require("../documents");
const formatting_1 = require("../formatting");
const hover_1 = require("../hover");
const JSONLanguageService_1 = require("../json/JSONLanguageService");
const translations_1 = require("../translations");
const utils_1 = require("../utils");
const version_1 = require("../version");
const Configuration_1 = require("./Configuration");
const defaultLogger = () => { };
/**
 * This code runs in node and the browser, it can't talk to the file system
 * or make requests. Stuff like that should be injected.
 *
 * In browser, theme-check-js wants these things:
 *   - fileExists(path)
 *   - defaultTranslations
 *
 * Which means we gotta provide 'em from here too!
 */
function startServer(connection, { fileExists, fileSize, filesForURI, findRootURI: findConfigurationRootURI, getDefaultLocaleFactory, getDefaultTranslationsFactory, getThemeSettingsSchemaForRootURI, loadConfig, log = defaultLogger, jsonValidationSet: remoteSchemaValidators, themeDocset: remoteThemeDocset, }) {
    const clientCapabilities = new ClientCapabilities_1.ClientCapabilities();
    const configuration = new Configuration_1.Configuration(connection, clientCapabilities);
    const documentManager = new documents_1.DocumentManager();
    const diagnosticsManager = new diagnostics_1.DiagnosticsManager(connection);
    const documentLinksProvider = new documentLinks_1.DocumentLinksProvider(documentManager);
    const codeActionsProvider = new codeActions_1.CodeActionsProvider(documentManager, diagnosticsManager);
    const onTypeFormattingProvider = new formatting_1.OnTypeFormattingProvider(documentManager);
    const findThemeRootURI = async (uri) => {
        const rootUri = await findConfigurationRootURI(uri);
        const config = await loadConfig(rootUri);
        const root = vscode_uri_1.URI.parse(rootUri).with({
            path: config.root,
        });
        return root.toString();
    };
    // These are augmented here so that the caching is maintained over different runs.
    const themeDocset = new theme_check_common_1.AugmentedThemeDocset(remoteThemeDocset);
    const jsonValidationSet = new theme_check_common_1.AugmentedJsonValidationSet(remoteSchemaValidators);
    const runChecks = (0, utils_1.debounce)((0, diagnostics_1.makeRunChecks)(documentManager, diagnosticsManager, {
        fileExists,
        fileSize,
        findRootURI: findConfigurationRootURI,
        getDefaultLocaleFactory,
        getDefaultTranslationsFactory,
        loadConfig,
        themeDocset,
        jsonValidationSet,
    }), 100);
    const getTranslationsForURI = async (uri) => {
        const rootURI = await findThemeRootURI(uri);
        const theme = documentManager.theme(rootURI);
        const getTranslationsFactory = (rootUri) => {
            return async () => {
                const [defaultTranslations, shopifyTranslations] = await Promise.all([
                    getDefaultTranslationsFactory(rootUri)(),
                    themeDocset.systemTranslations(),
                ]);
                return { ...defaultTranslations, ...shopifyTranslations };
            };
        };
        return (0, translations_1.useBufferOrInjectedTranslations)(getTranslationsFactory, theme, rootURI);
    };
    const getSnippetNamesForURI = async (uri) => {
        if (!filesForURI)
            return [];
        const files = await filesForURI(uri);
        return files
            .filter((x) => x.startsWith('snippets'))
            .map((x) => x
            .replace(/\\/g, '/')
            .replace(/^snippets\//, '')
            .replace(/\..*$/, ''));
    };
    const getThemeSettingsSchemaForURI = async (uri) => {
        const rootUri = await findThemeRootURI(uri);
        return getThemeSettingsSchemaForRootURI(rootUri);
    };
    const jsonLanguageService = new JSONLanguageService_1.JSONLanguageService(documentManager, jsonValidationSet);
    const completionsProvider = new completions_1.CompletionsProvider({
        documentManager,
        themeDocset,
        getTranslationsForURI,
        getSnippetNamesForURI,
        getThemeSettingsSchemaForURI,
        log,
    });
    const hoverProvider = new hover_1.HoverProvider(documentManager, themeDocset, getTranslationsForURI, getThemeSettingsSchemaForURI);
    const executeCommandProvider = new commands_1.ExecuteCommandProvider(documentManager, diagnosticsManager, clientCapabilities, runChecks, connection);
    connection.onInitialize((params) => {
        clientCapabilities.setup(params.capabilities, params.initializationOptions);
        jsonLanguageService.setup(params.capabilities);
        configuration.setup();
        const fileOperationRegistrationOptions = {
            filters: [
                {
                    scheme: 'file',
                    pattern: {
                        glob: '**/*.{liquid,json}',
                    },
                },
            ],
        };
        const result = {
            capabilities: {
                textDocumentSync: {
                    change: vscode_languageserver_1.TextDocumentSyncKind.Full,
                    save: true,
                    openClose: true,
                },
                codeActionProvider: {
                    codeActionKinds: [...codeActions_1.CodeActionKinds],
                },
                completionProvider: {
                    triggerCharacters: ['.', '{{ ', '{% ', '<', '/', '[', '"', "'"],
                },
                documentOnTypeFormattingProvider: {
                    firstTriggerCharacter: ' ',
                    moreTriggerCharacter: ['{', '%', '-'],
                },
                documentLinkProvider: {
                    resolveProvider: false,
                    workDoneProgress: false,
                },
                executeCommandProvider: {
                    commands: [...commands_1.Commands],
                },
                hoverProvider: {
                    workDoneProgress: false,
                },
                workspace: {
                    fileOperations: {
                        didRename: fileOperationRegistrationOptions,
                        didCreate: fileOperationRegistrationOptions,
                        didDelete: fileOperationRegistrationOptions,
                    },
                },
            },
            serverInfo: {
                name: 'theme-language-server',
                version: version_1.VERSION,
            },
        };
        return result;
    });
    connection.onInitialized(() => {
        log(`[SERVER] Let's roll!`);
        configuration.fetchConfiguration();
        configuration.registerDidChangeCapability();
    });
    connection.onDidChangeConfiguration((_params) => {
        configuration.clearCache();
    });
    connection.onDidOpenTextDocument(async (params) => {
        const { uri, text, version } = params.textDocument;
        documentManager.open(uri, text, version);
        if (await configuration.shouldCheckOnOpen()) {
            runChecks([uri]);
        }
    });
    connection.onDidChangeTextDocument(async (params) => {
        const { uri, version } = params.textDocument;
        documentManager.change(uri, params.contentChanges[0].text, version);
        if (await configuration.shouldCheckOnChange()) {
            runChecks([uri]);
        }
        else {
            // The diagnostics may be stale! Clear em!
            diagnosticsManager.clear(params.textDocument.uri);
        }
    });
    connection.onDidSaveTextDocument(async (params) => {
        const { uri } = params.textDocument;
        if (await configuration.shouldCheckOnSave()) {
            runChecks([uri]);
        }
    });
    connection.onDidCloseTextDocument((params) => {
        const { uri } = params.textDocument;
        documentManager.close(uri);
        diagnosticsManager.clear(uri);
    });
    connection.onDocumentLinks(async (params) => {
        const { uri } = params.textDocument;
        const rootUri = await findThemeRootURI(uri);
        return documentLinksProvider.documentLinks(uri, rootUri);
    });
    connection.onCodeAction(async (params) => {
        return codeActionsProvider.codeActions(params);
    });
    connection.onExecuteCommand(async (params) => {
        await executeCommandProvider.execute(params);
    });
    connection.onCompletion(async (params) => {
        var _a;
        return ((_a = (await jsonLanguageService.completions(params))) !== null && _a !== void 0 ? _a : (await completionsProvider.completions(params)));
    });
    connection.onHover(async (params) => {
        var _a;
        return (_a = (await jsonLanguageService.hover(params))) !== null && _a !== void 0 ? _a : (await hoverProvider.hover(params));
    });
    connection.onDocumentOnTypeFormatting(async (params) => {
        return onTypeFormattingProvider.onTypeFormatting(params);
    });
    // These notifications could cause a MissingSnippet check to be invalidated
    //
    // It is not guaranteed that the file is or was opened when it was
    // created/renamed/deleted. If we're smart, we're going to re-lint for
    // every root affected. Unfortunately, we can't just use the debounced
    // call because we could run in a weird timing issue where didOpen
    // happens after the didRename and causes the 'lastArgs' to skip over the
    // ones we were after.
    //
    // So we're using runChecks.force for that.
    connection.workspace.onDidCreateFiles((params) => {
        const triggerUris = params.files.map((fileCreate) => fileCreate.uri);
        runChecks.force(triggerUris);
    });
    connection.workspace.onDidRenameFiles((params) => {
        const triggerUris = params.files.map((fileRename) => fileRename.newUri);
        runChecks.force(triggerUris);
    });
    connection.workspace.onDidDeleteFiles((params) => {
        const triggerUris = params.files.map((fileDelete) => fileDelete.uri);
        runChecks.force(triggerUris);
    });
    connection.listen();
}
exports.startServer = startServer;
//# sourceMappingURL=startServer.js.map