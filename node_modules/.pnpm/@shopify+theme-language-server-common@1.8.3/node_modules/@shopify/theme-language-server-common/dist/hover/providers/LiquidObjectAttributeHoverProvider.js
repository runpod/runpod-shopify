"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidObjectAttributeHoverProvider = void 0;
const liquid_html_parser_1 = require("@shopify/liquid-html-parser");
const TypeSystem_1 = require("../../TypeSystem");
const docset_1 = require("../../docset");
class LiquidObjectAttributeHoverProvider {
    constructor(typeSystem) {
        this.typeSystem = typeSystem;
    }
    async hover(currentNode, ancestors, params) {
        var _a;
        const parentNode = ancestors.at(-1);
        if (currentNode.type !== liquid_html_parser_1.NodeTypes.String ||
            !parentNode ||
            parentNode.type !== liquid_html_parser_1.NodeTypes.VariableLookup ||
            !parentNode.lookups.includes(currentNode)) {
            return null;
        }
        const lookupIndex = parentNode.lookups.findIndex((lookup) => lookup === currentNode);
        const node = {
            ...parentNode,
            lookups: parentNode.lookups.slice(0, lookupIndex),
        };
        const parentType = await this.typeSystem.inferType(node, ancestors[0], params.textDocument.uri);
        if ((0, TypeSystem_1.isArrayType)(parentType)) {
            return null;
        }
        const objectMap = await this.typeSystem.objectMap(params.textDocument.uri, ancestors[0]);
        const parentEntry = objectMap[parentType];
        if (!parentEntry) {
            return null;
        }
        const parentTypeProperties = ((_a = objectMap[parentType]) === null || _a === void 0 ? void 0 : _a.properties) || [];
        const entry = parentTypeProperties.find((p) => p.name === currentNode.value);
        if (!entry) {
            return null;
        }
        return {
            contents: {
                kind: 'markdown',
                value: (0, docset_1.render)(entry),
            },
        };
    }
}
exports.LiquidObjectAttributeHoverProvider = LiquidObjectAttributeHoverProvider;
//# sourceMappingURL=LiquidObjectAttributeHoverProvider.js.map