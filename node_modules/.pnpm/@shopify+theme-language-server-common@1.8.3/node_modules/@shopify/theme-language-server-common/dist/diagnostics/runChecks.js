"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRunChecks = void 0;
const theme_check_common_1 = require("@shopify/theme-check-common");
const translations_1 = require("../translations");
const vscode_uri_1 = require("vscode-uri");
function makeRunChecks(documentManager, diagnosticsManager, { loadConfig, findRootURI, fileSize, fileExists, getDefaultTranslationsFactory, getDefaultLocaleFactory, themeDocset, jsonValidationSet, }) {
    return async function runChecks(triggerURIs) {
        // This function takes an array of triggerURIs so that we can correctly
        // recheck on file renames that came from out of bounds in a
        // workspaces.
        //
        // e.g. if a user renames
        //  theme1/snippets/a.liquid to
        //  theme1/snippets/b.liquid
        //
        // then we recheck theme1
        const rootURIs = await Promise.all(triggerURIs.map(findRootURI));
        const deduplicatedRootURIs = new Set(rootURIs);
        await Promise.all([...deduplicatedRootURIs].map(runChecksForRoot));
        return;
        async function runChecksForRoot(configFileRoot) {
            const configFileRootURI = vscode_uri_1.URI.parse(configFileRoot);
            const config = await loadConfig(configFileRoot);
            const rootURI = configFileRootURI.with({
                path: config.root,
            });
            const theme = documentManager.theme(rootURI.toString());
            const defaultTranslations = await (0, translations_1.useBufferOrInjectedTranslations)(getDefaultTranslationsFactory, theme, rootURI.toString());
            const offenses = await (0, theme_check_common_1.check)(theme, config, {
                fileExists,
                fileSize,
                getDefaultLocale: getDefaultLocaleFactory(rootURI.toString()),
                getDefaultTranslations: async () => defaultTranslations,
                jsonValidationSet,
                themeDocset,
            });
            // We iterate over the theme files (as opposed to offenses) because if
            // there were offenses before, we need to send an empty array to clear
            // them.
            for (const sourceCode of theme) {
                const sourceCodeOffenses = offenses.filter((offense) => offense.absolutePath === sourceCode.absolutePath);
                diagnosticsManager.set(sourceCode.uri, sourceCode.version, sourceCodeOffenses);
            }
        }
    };
}
exports.makeRunChecks = makeRunChecks;
//# sourceMappingURL=runChecks.js.map