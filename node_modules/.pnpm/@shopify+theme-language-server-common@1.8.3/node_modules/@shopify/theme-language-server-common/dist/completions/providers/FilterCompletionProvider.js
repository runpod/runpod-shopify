"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterCompletionProvider = void 0;
const liquid_html_parser_1 = require("@shopify/liquid-html-parser");
const vscode_languageserver_1 = require("vscode-languageserver");
const TypeSystem_1 = require("../../TypeSystem");
const utils_1 = require("../../utils");
const params_1 = require("../params");
const common_1 = require("./common");
class FilterCompletionProvider {
    constructor(typeSystem) {
        this.typeSystem = typeSystem;
        this.options = (0, utils_1.memoize)(async (inputType) => {
            const filterEntries = await this.typeSystem.filterEntries();
            const options = filterEntries
                .filter((entry) => { var _a; return (_a = entry.syntax) === null || _a === void 0 ? void 0 : _a.startsWith(inputType); })
                .sort(common_1.sortByName);
            // Case we take "anything" as argument
            if (inputType === 'variable') {
                const entriesWithoutSyntax = filterEntries.filter((entry) => !entry.syntax);
                return options.concat(entriesWithoutSyntax).sort(common_1.sortByName);
            }
            // Case there doesn't exist filter entries for that type
            if (options.length === 0) {
                return filterEntries.sort(common_1.sortByName);
            }
            const untypedOptions = await this.options('variable');
            // We show 'array' options before 'untyped' options because they feel
            // like better options.
            return [...options, ...untypedOptions.map(deprioritized)];
        }, (inputType) => inputType);
    }
    async completions(params) {
        if (!params.completionContext)
            return [];
        const { partialAst, node, ancestors } = params.completionContext;
        if (!node || node.type !== liquid_html_parser_1.NodeTypes.LiquidFilter) {
            return [];
        }
        if (node.args.length > 0) {
            // We only do name completion
            return [];
        }
        // We'll fake a LiquidVariable
        let parentVariable = ancestors.at(-1);
        if (!parentVariable ||
            parentVariable.type !== liquid_html_parser_1.NodeTypes.LiquidVariable ||
            parentVariable.filters.at(-1) !== node) {
            return []; // something went wrong...
        }
        // We'll infer the type of the variable up to the last filter (excluding this one)
        parentVariable = { ...parentVariable }; // soft clone
        parentVariable.filters = parentVariable.filters.slice(0, -1); // remove last one
        const inputType = await this.typeSystem.inferType(parentVariable, partialAst, params.textDocument.uri);
        const partial = node.name.replace(params_1.CURSOR, '');
        const options = await this.options((0, TypeSystem_1.isArrayType)(inputType) ? 'array' : inputType);
        return completionItems(options, partial);
    }
}
exports.FilterCompletionProvider = FilterCompletionProvider;
function deprioritized(entry) {
    return { ...entry, deprioritized: true };
}
function completionItems(options, partial) {
    return options.filter(({ name }) => name.startsWith(partial)).map(toPropertyCompletionItem);
}
function toPropertyCompletionItem(entry) {
    return (0, common_1.createCompletionItem)(entry, {
        kind: vscode_languageserver_1.CompletionItemKind.Function,
    }, 'filter');
}
//# sourceMappingURL=FilterCompletionProvider.js.map