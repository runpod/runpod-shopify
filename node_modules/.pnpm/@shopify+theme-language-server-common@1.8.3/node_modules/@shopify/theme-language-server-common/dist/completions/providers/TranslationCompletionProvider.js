"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranslationCompletionProvider = void 0;
const liquid_html_parser_1 = require("@shopify/liquid-html-parser");
const vscode_languageserver_1 = require("vscode-languageserver");
const translations_1 = require("../../translations");
const visitor_1 = require("../../visitor");
class TranslationCompletionProvider {
    constructor(documentManager, getTranslationsForURI) {
        this.documentManager = documentManager;
        this.getTranslationsForURI = getTranslationsForURI;
    }
    async completions(params) {
        if (!params.completionContext)
            return [];
        const { node, ancestors } = params.completionContext;
        const parentNode = ancestors.at(-1);
        const document = this.documentManager.get(params.textDocument.uri);
        if (!node ||
            node.type !== liquid_html_parser_1.NodeTypes.String ||
            !parentNode ||
            parentNode.type !== liquid_html_parser_1.NodeTypes.LiquidVariable ||
            !document) {
            return [];
        }
        const ast = document.ast;
        const textDocument = document.textDocument;
        const translations = await this.getTranslationsForURI(params.textDocument.uri);
        const partial = node.value;
        const options = translationOptions(translations, partial);
        const [_currentNode, realAncestors] = ast instanceof Error
            ? [null, []]
            : (0, visitor_1.findCurrentNode)(ast, textDocument.offsetAt(params.position));
        // That part feels kind of gross, let me explain...
        // When we complete translations, we also want to append the `| t` after the
        // string, but we should only ever do that if the variable didn't _already_ have that.
        // But since our completion engine works on incomplete code, we need to temporarily
        // fetch the real node to do the optional | t completion.
        const realParentNode = realAncestors.at(-1);
        let shouldAppendTranslateFilter = (realParentNode === null || realParentNode === void 0 ? void 0 : realParentNode.type) === liquid_html_parser_1.NodeTypes.LiquidVariable && (realParentNode === null || realParentNode === void 0 ? void 0 : realParentNode.filters.length) === 0;
        const quote = node.single ? "'" : '"';
        let postFix = quote + ' | t';
        let replaceRange;
        if (shouldAppendTranslateFilter) {
            postFix = quote + ' | t';
            replaceRange = {
                start: textDocument.positionAt(node.position.start + 1),
                end: textDocument.positionAt(node.position.end), // including quote
            };
        }
        else {
            postFix = '';
            replaceRange = {
                start: textDocument.positionAt(node.position.start + 1),
                end: textDocument.positionAt(node.position.end - 1), // excluding quote
            };
        }
        const insertTextStartIndex = partial.lastIndexOf('.') + 1;
        return options.map((option) => ({
            label: quote + option.path.join('.') + quote + ' | t',
            insertText: option.path.join('.').slice(insertTextStartIndex),
            kind: vscode_languageserver_1.CompletionItemKind.Field,
            textEdit: vscode_languageserver_1.TextEdit.replace(replaceRange, option.path.join('.') + postFix),
            documentation: {
                kind: 'markdown',
                value: (0, translations_1.renderTranslation)(option.translation),
            },
        }));
    }
}
exports.TranslationCompletionProvider = TranslationCompletionProvider;
function isPluralizedTranslation(translations) {
    return translations_1.PluralizedTranslationKeys.some((key) => key in translations);
}
function toOptions(prefix, translations) {
    return Object.entries(translations).flatMap(([path, translation]) => {
        if (typeof translation === 'string' || isPluralizedTranslation(translation)) {
            return [{ path: prefix.concat(path), translation }];
        }
        else {
            return toOptions(prefix.concat(path), translation);
        }
    });
}
function translationOptions(translations, partial) {
    const options = toOptions([], translations);
    return options.filter((option) => option.path.join('.').startsWith(partial));
}
//# sourceMappingURL=TranslationCompletionProvider.js.map