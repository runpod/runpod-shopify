"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiquidTagsCompletionProvider = void 0;
const liquid_html_parser_1 = require("@shopify/liquid-html-parser");
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("../../utils");
const params_1 = require("../params");
const common_1 = require("./common");
class LiquidTagsCompletionProvider {
    constructor(themeDocset) {
        this.themeDocset = themeDocset;
    }
    async completions(params) {
        if (!params.completionContext)
            return [];
        const { node, ancestors } = params.completionContext;
        if (!node || node.type !== liquid_html_parser_1.NodeTypes.LiquidTag) {
            return [];
        }
        if (typeof node.markup !== 'string' || node.markup !== '') {
            return [];
        }
        const partial = node.name.replace(params_1.CURSOR, '');
        const blockParent = findParentNode(partial, ancestors);
        const tags = await this.themeDocset.tags();
        return tags
            .filter(({ name }) => name.startsWith(partial))
            .sort(common_1.sortByName)
            .map((tag) => (0, common_1.createCompletionItem)(tag, { kind: vscode_languageserver_1.CompletionItemKind.Keyword }, 'tag'))
            .concat(blockParent && `end${blockParent.name}`.startsWith(partial)
            ? {
                label: `end${blockParent.name}`,
                kind: vscode_languageserver_1.CompletionItemKind.Keyword,
                sortText: `!end${blockParent.name}`, // we want this first.
            }
            : []);
    }
}
exports.LiquidTagsCompletionProvider = LiquidTagsCompletionProvider;
function findParentNode(partial, ancestors) {
    if (!'end'.startsWith(partial))
        return;
    // This covers the scenario where we have a dangling conditional tag
    //
    // e.g.
    // {% if cond %}
    //   hello
    // {% end %}
    //
    // In that scenario, we have the following tree:
    //
    // type: Document
    // children:
    //   - LiquidTag#if
    //     children:
    //       - LiquidBranch
    //         children:
    //           - TextNode#hello
    //           - LiquidTag#end
    const potentialParentName = partial.replace(/^e(nd?)?/, '');
    const parentNode = ancestors.at(-1);
    const grandParentNode = ancestors.at(-2);
    if (parentNode &&
        parentNode.type === 'LiquidBranch' &&
        grandParentNode &&
        grandParentNode.type === 'LiquidTag' &&
        grandParentNode.name.startsWith(potentialParentName)) {
        return grandParentNode;
    }
    // This covers the scenario where we have a dangling block tag
    //
    // e.g.
    // {% form "cart", cart %}
    //   hello
    // {% end %}
    //
    // In that scenario, we have the following tree:
    //
    // type: Document
    // children:
    //   - LiquidTag#form
    //     children:
    //       - TextNode#hello
    //       - LiquidTag#end
    if (parentNode &&
        parentNode.type === 'LiquidTag' &&
        parentNode.name.startsWith(potentialParentName)) {
        return parentNode;
    }
    // This covers the case where a raw tag is being parsed as a LiquidTag
    // because of the missing endtag.
    //
    // e.g.
    // {% comment %}
    //   hello
    // {% end %}
    //
    // In that scenario, we have the following tree:
    //
    // type: Document
    // children:
    //   - LiquidTag#comment
    //   - TextNode#hello
    //   - LiquidTag#end
    let previousNode;
    if (parentNode &&
        'children' in parentNode &&
        Array.isArray(parentNode.children) &&
        (previousNode = (0, utils_1.findLast)(parentNode.children, (node) => node.type === 'LiquidTag' &&
            node.name.startsWith(potentialParentName) &&
            (liquid_html_parser_1.BLOCKS.includes(node.name) || liquid_html_parser_1.RAW_TAGS.includes(node.name))))) {
        return previousNode;
    }
}
//# sourceMappingURL=LiquidTagsCompletionProvider.js.map