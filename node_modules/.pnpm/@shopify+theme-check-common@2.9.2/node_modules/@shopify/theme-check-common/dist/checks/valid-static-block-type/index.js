"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidStaticBlockType = void 0;
const types_1 = require("../../types");
const file_utils_1 = require("../../utils/file-utils");
const markup_1 = require("../../utils/markup");
exports.ValidStaticBlockType = {
    meta: {
        code: 'ValidStaticBlockType',
        name: 'Prevent use of type that is not valid for static blocks',
        docs: {
            description: 'This check is aimed at preventing the use of an invalid type for blocks rendered statically.',
            url: 'https://shopify.dev/docs/storefronts/themes/tools/theme-check/checks/valid-static-block-type',
            recommended: true,
        },
        type: types_1.SourceCodeType.LiquidHtml,
        severity: types_1.Severity.ERROR,
        schema: {},
        targets: [],
    },
    create(context) {
        const typeRegex = /type:\s*["'](\S+)["']/;
        return {
            async LiquidTag(node) {
                if (node.name !== 'content_for') {
                    return;
                }
                if (!(0, markup_1.isContentForBlock)(node.markup)) {
                    return;
                }
                const typeValueMatch = typeRegex.exec(node.markup);
                if (typeValueMatch == null) {
                    return;
                }
                const [entireTypeTerm, filteredTypeValue] = typeValueMatch;
                const relativePath = `blocks/${filteredTypeValue}.liquid`;
                const fileExists = await (0, file_utils_1.doesFileExist)(context, relativePath);
                if (!fileExists) {
                    const [blockType] = node.markup.split(',');
                    const nodeInSource = node.source.substring(node.position.start);
                    const contentForBlockStartIndex = nodeInSource.indexOf(blockType);
                    const typeParamIndex = typeValueMatch.index + contentForBlockStartIndex;
                    const typeParamValueLength = entireTypeTerm.length;
                    const typeParamValueEndIndex = typeParamIndex + typeParamValueLength;
                    context.report({
                        message: `The type '${filteredTypeValue}' is not valid, use a type that exists in the blocks directory`,
                        startIndex: node.position.start + typeParamIndex,
                        endIndex: node.position.start + typeParamValueEndIndex,
                        suggest: [],
                    });
                }
            },
        };
    },
};
//# sourceMappingURL=index.js.map